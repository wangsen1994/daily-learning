- 在beego中controller自带实现了部分数据与方法接口，对于自定义的controller通常是以`beego.Controller`为基础，然后对方法接口进行实现

- Go 中`init`函数运行时间是当一个package被`import`时，则会被调用，具有递归调用特性

- 对于业务的处理时，请求体中保存了请求的表单，而请求行中也可以包含部分数据，例如GET方法
  
  - 先启动mongodb 再启动服务器`supervisorctl restart all`，最后启动longyang `./bin/longyang`,输入用户信息`go2 ws lo 22012` 杀死应用`./kill.sh`或`./kill_rpc.sh`
  
- grpc代码对protoc生成的pb.go函数进行了一层包裹，先通过Dial实现网络的连接，再调用newclient实现将客户端嵌入到gRPC协议里面，服务器端调用listen创建监听端口，再调用`grpc.newserver`创建服务端，并将服务端实现的接口`Register`到服务端里，并开启服务。

- NSQ中一个nsqd有多个topic，一个topic对应多个channel，通过lookupd服务来获取所有的nsqd服务地址并连接

- CGI，全拼 (Common Gateway Interface) 是能让 web 服务器和 CGI 脚本共同处理客户的请求的协议。Web 服务器把请求转成 CGI 脚本，CGI 脚本执行回复 Web 服务器，Web 服务回复给客户端

- go变量的调用时，其变量名多和地址相关联，所以注意值是否发生改变。

- Returen 的执行流程 1、给返回值赋值  2、调用defer表达式  3、返回给调用函数

- go2 chuan2 wz 2011。get users[49081324].SfMarket

- make g;make tt

- ITUserPVPSolo

- Ubuntu 用户密码：skgj@i35L

- 聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致**。非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据；覆盖索引是一种例外可以不使用聚集索引就能查询所需要的数据，其通过将将两个字段作为索引create index index_birthday_and_user_name on user_info(birthday, user_name); 当你通过birthday查询时，叶节点中除了有表主键ID的值以外，还有user_name字段值，所以不许通过聚集索引再来进行查询。

- Mongodb是基于(Journaling)日志的形式进行持久化的，当执行一个写操作，mongodb将创建一个journal来包含确切的磁盘更改，若服务器崩溃，启动时journal会重放崩溃前并没有刷新到磁盘上的操作。文件每隔60m刷新到磁盘，因此jouranl只需持有60s的写入数据。当正常关机时，mongo会清除这些文件，但是服务器崩溃启动时，会重放journal文件。为了保证写操作的效率，mongo采用每隔100ms写入一次journal日志，即是批量提交更改，每个写操纵不立即刷新到磁盘，所以最多损失100ms的数据。

  对于一些要求更高的请求，mongo的日志持久化不能满足要求，可采用的方法。

  - 有规划的批提交 db.runCommand({"getLastError" : 1, "j" : true})会等待上一次的写操作写入journal日志中，只会等待30s；
  - 设置提交间隔，即是缩短两次journal提交

- having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前

- 常量指针 int const * p 或 const int * p   指针常量 int * const p 必须被初始化

- undo主要用于存放数据被修改前的值，用于对事务的回滚，undo log主要分两种类型，一种是INSERT_UNDO，记录插入的唯一键值，一种是UPDATE_UNDO（包含update与delete操作），记录修改的唯一键值以及old column记录。保证事务的一致性。

- redo log主要用于保障数据修改的一致性，由于修改数据，需先把数据读取到内存buffer中，修改后再保存到磁盘，若此时crash，则会出现数据不一致的现象。

- undo主要用于保证数据的一致性，其要求在事务提交前将undo log写入磁盘，但是频繁进行磁盘的IO会降低性能，所以引入了redo log可以保证数据的持久性，也是需要在事务提交前将redo log进行持久化，但是可以通过保存redo log在连续空间，批量写入日志等操作来对IO性能进行优化。

- join用于对线程的结合，调用他的线程需等待该线程的结束再来执行（阻塞在调用join的地方），其可以被其他线程结束，pthread_exit（其只是结束线程，但是线程的资源并没有回收，会造成内存泄漏），尽量不要用pthread_exit来结束线程，可在主线程末尾调用join来回收资源，而detach函数用于分离线程，分离出的线程由系统对其进行回收，不会造成泄漏。默认是joinable的。主要用于对线程资源的管理。主线程调用pthread_exit退出不会影响其他线程，但其资源并没有被回收，若是调用return或_exit则会结束整个进程。

- /data/warzone/center/log  日志位置

- ssh j.tap4fun.com  gitub地址

- skgj@i35L  ubuntu账号密码

- /data/gs_log_bak/gs_log gs日志
