- 在beego中controller自带实现了部分数据与方法接口，对于自定义的controller通常是以`beego.Controller`为基础，然后对方法接口进行实现

- Go 中`init`函数运行时间是当一个package被`import`时，则会被调用，具有递归调用特性

- 对于业务的处理时，请求体中保存了请求的表单，而请求行中也可以包含部分数据，例如GET方法

  - 先启动mongodb 再启动服务器`supervisorctl restart all`，最后启动longyang `./bin/longyang`,输入用户信息`go2 ws lo 22012` 杀死应用`./kill.sh`或`./kill_rpc.sh`

- grpc代码对protoc生成的pb.go函数进行了一层包裹，先通过Dial实现网络的连接，再调用newclient实现将客户端嵌入到gRPC协议里面，服务器端调用listen创建监听端口，再调用`grpc.newserver`创建服务端，并将服务端实现的接口`Register`到服务端里，并开启服务。

- NSQ中一个nsqd有多个topic，一个topic对应多个channel，通过lookupd服务来获取所有的nsqd服务地址并连接

- CGI，全拼 (Common Gateway Interface) 是能让 web 服务器和 CGI 脚本共同处理客户的请求的协议。Web 服务器把请求转成 CGI 脚本，CGI 脚本执行回复 Web 服务器，Web 服务回复给客户端

- go变量的调用时，其变量名多和地址相关联，所以注意值是否发生改变。

- Returen 的执行流程 1、给返回值赋值  2、调用defer表达式  3、返回给调用函数

- go2 chuan2 wz 2011。get users[49081324].SfMarket

- make g;make tt

- ITUserPVPSolo

- Ubuntu 用户密码：skgj@i35L

- 聚集索引和非聚集索引的根本区别是**表记录的排列顺序和与索引的排列顺序是否一致**。非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据；覆盖索引是一种例外可以不使用聚集索引就能查询所需要的数据，其通过将将两个字段作为索引create index index_birthday_and_user_name on user_info(birthday, user_name); 当你通过birthday查询时，叶节点中除了有表主键ID的值以外，还有user_name字段值，所以不许通过聚集索引再来进行查询。

- Mongodb是基于(Journaling)日志的形式进行持久化的，当执行一个写操作，mongodb将创建一个journal来包含确切的磁盘更改，若服务器崩溃，启动时journal会重放崩溃前并没有刷新到磁盘上的操作。文件每隔60m刷新到磁盘，因此jouranl只需持有60s的写入数据。当正常关机时，mongo会清除这些文件，但是服务器崩溃启动时，会重放journal文件。为了保证写操作的效率，mongo采用每隔100ms写入一次journal日志，即是批量提交更改，每个写操纵不立即刷新到磁盘，所以最多损失100ms的数据。

  对于一些要求更高的请求，mongo的日志持久化不能满足要求，可采用的方法。

  - 有规划的批提交 db.runCommand({"getLastError" : 1, "j" : true})会等待上一次的写操作写入journal日志中，只会等待30s；
  - 设置提交间隔，即是缩短两次journal提交

- having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前

- 常量指针 int const * p 或 const int * p   指针常量 int * const p 必须被初始化

- undo主要用于存放数据被修改前的值，用于对事务的回滚，undo log主要分两种类型，一种是INSERT_UNDO，记录插入的唯一键值，一种是UPDATE_UNDO（包含update与delete操作），记录修改的唯一键值以及old column记录。保证事务的一致性。

- redo log主要用于保障数据修改的一致性，由于修改数据，需先把数据读取到内存buffer中，修改后再保存到磁盘，若此时crash，则会出现数据不一致的现象。

- undo主要用于保证数据的一致性，其要求在事务提交前将undo log写入磁盘，但是频繁进行磁盘的IO会降低性能，所以引入了redo log可以保证数据的持久性，也是需要在事务提交前将redo log进行持久化，但是可以通过保存redo log在连续空间，批量写入日志等操作来对IO性能进行优化。

- join用于对线程的结合，调用他的线程需等待该线程的结束再来执行（阻塞在调用join的地方），其可以被其他线程结束，pthread_exit（其只是结束线程，但是线程的资源并没有回收，会造成内存泄漏），尽量不要用pthread_exit来结束线程，可在主线程末尾调用join来回收资源，而detach函数用于分离线程，分离出的线程由系统对其进行回收，不会造成泄漏。默认是joinable的。主要用于对线程资源的管理。主线程调用pthread_exit退出不会影响其他线程，但其资源并没有被回收，若是调用return或_exit则会结束整个进程。

- /data/warzone/center/log  日志位置

- ssh j.tap4fun.com  gitub地址

- skgj@i35L  ubuntu账号密码

- /data/gs_log_bak/gs_log gs日志

- Git pull 拉文件下来

- super_gm FinishBuilding(179774,)

- sh tool.sh（好像和lua有关,在用户目录lua下，运行sh tool.sh）

- [http://vim.spf13.com/#vimrc](http://vim.spf13.com/#vimrc)

- ctags

- Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。

- Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。

-   缓存（cached）是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除。 缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期清空缓冲内容（即写如磁盘），也可以通过sync命令手动清空缓冲。

- git fetch：从远程获取最新版本到本地，不自动merge

- git pull：从远程获取最新版本并merge到本地，在实际使用中，git fetch更加安全一些。

- git merge 自动创建一个新的commit，遇到冲突时，仅需修改后重新commit，记录了真实的commit情况，包括每个分支的情况。

- git rebase 会合并之前的commit历史，得到更简洁的项目历史，去掉了merge commit。

- 通过观察反汇编代码，我们可以得出这样的结论：编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

- 宏定义与模板区别
  - 宏是在预处理阶段处理，模板是在编译阶段处理
  - 宏不会进行类型检查，只会单纯的进行文本替换，模板会进行类型检查。比如下面代码模板就会出错，而宏不会
  - 宏直接就可以产生代码，而编译器遇到模板定义时，并不产生代码，只有当模板实例化后时才会产生代码。
  
- 识别全局变量和局部变量应该是靠符号表内的记录的层次

- vector中的reserve()函数用来定义**预留空间**，改变capacity，不改变size。会去分配内存，但不会构造出对象。如果改变后的capacity比当前的capacity大，则capacity会变为改变后的capacity，反之capacity不变。

- resize用来改变vector的size，有可能也会改变capacity。如果改变后的size比当前capacity大，则capacity会变大，同时构造出多出来的对象；反之，capacity不变，同时析构一些不再需要的对象。

- 进程切换分两步

  - 切换页目录以使用新的地址空间
  - 切换内核栈和硬件上下文。

  于linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。所以明显是进程切换代价大。线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。

- 系统调用的整个过程如下：首先指令流执行到系统调用函数时，系统调用函数通过int 0x80指令进入系统调用入口程序，并且把系统调用号放入%eax中，如果需要传递参数，则把参数放入%ebx，%ecx和%edx中。进入系统调用入口程序（System_call）后，它首先把相关的寄存器压入内核堆栈（以备将来恢复），这个过程称为保护现场。保护现场的工作完成后，开始检查系统调用号是不是一个有效值，如果不是则退出。接下来根据系统调用号开始调用系统调用处理程序（这是一个正式执行系统调用功能的函数），从系统调用处理程序返回后，就会去检查当前进程是否处于就绪态、进程时间片是否用完，如果不在就绪态或者时间片已用完，那么就会去调用进程调度程序schedule()，转去执行其他进程。如果不执行进程调度程序，那么接下来就会开始执行ret_from_sys_call，顾名思义，这这个程序主要执行一些系统调用的后处理工作。比如它会去检查当前进程是否有需要处理的信号，如果有则去调用do_signal()，然后进行一些恢复现场的工作，返回到原先的进程指令流中。至此整个系统调用的过程就结束了。

- *TTL*(Time-To-Live)数据包能在网络上生存的时间

- extern C的主要作用是为了能够正确实现C++代码调用其他C语言代码，加上extern C后会指示编译器这部分代码按C语言进行编译，由于C++支持函数重载，因此编译器会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名，C语言并不支持函数的重载。

- XSS（跨站脚本攻击）：攻击者在网页中嵌入恶意脚本程序，用户请求网页后，执行了恶意的脚本。

- CSRF（跨站请求伪造）：网站 A 对用户建立信任关系后，在网站 B 上利用这种信任关系，跨站点向网站 A 发起一些伪造的用户操作请求，以达到攻击的目的。

- SQL注入：SQL语句伪装成正常的http请求参数，传到服务器，服务器执行sql命令造成对数据库进行攻击。

- DDOS（例如SYN洪泛）：发送大量请求是使服务器瘫痪。

- session和cookie区别，cookie的加密与安全性保证，cookie和session生命周期，什么时候失效https的建立过程，优缺点，什么时候使用对称加密什么时候使用非对称加密 ，http2.0 http1.1 特点区别。
